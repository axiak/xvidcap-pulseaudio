/* 
 * xtoffmpeg.c
 *
 * Copyright (C) 2003 Karl H. Beckers, Frankfurt
 * EMail: khb@jarre-de-the.net
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 *
 */


#ifdef HAVE_CONFIG_H
# include <config.h>
#endif // HAVE_CONFIG_H

#define DEBUGFILE "xtoffmpeg.c"

#ifdef HAVE_LIBAVCODEC

#include <stdio.h>
#include <stdlib.h>
#include <limits.h>
#include <sys/types.h>
#include <unistd.h>
#include <fcntl.h>
#include <string.h>
#include <sys/time.h>           // for timeval struct and related functions

#include <X11/Intrinsic.h>

// xvidcap specific
#include "app_data.h"
#include "job.h"
#include "colors.h"
#include "frame.h"
#include "codecs.h"

// ffmpeg stuff
#include <ffmpeg/avcodec.h>
#include <ffmpeg/avformat.h>
#define PIX_FMT_ARGB32 PIX_FMT_RGBA32   // this is just my personal convenience

/* globals
 *
 * first libavcodec related stuff
 */
extern xvCodec tCodecs[NUMCODECS];
extern xvFFormat tFFormats[NUMCODECS];
extern xvAuCodec tAuCodecs[NUMAUCODECS];

static AVCodec *codec;                  // params for the codecs video 
//static AVCodecContext *c = NULL;        // codec context video 
static AVPicture inpic, *p_inpic;       // a AVPicture as wrapper around the
                                        // original image data 
static AVPicture outpic, *p_outpic;     // and one for the image converted to
                                        // yuv420p 
static AVFrame *frame;                  // the encoder takes a frame for its
                                        // input, so convert outpic to AVFrame 
static uint8_t *pic_out, *outbuf;       // output buffer for encoded frame ---
                                        // post 0.4.6 speak
static AVFormatContext *output_file;    // output file via avformat 
static AVOutputFormat *file_oformat;    // ... plus related data 
static AVStream *out_st = NULL;         // ... 

static int image_size, input_pixfmt;    // size of yuv image, pix_fmt of
                                        // original image 
static int out_size;                    // size of the encoded frame to write to
                                        // file 
static double audio_pts, video_pts;

static ColorInfo c_info;
static uint8_t *scratchbuf8bit;



static void
do_video_out(AVFormatContext * s, AVStream * ost,
             unsigned char *buf, int size)
{
    #define DEBUGFUNCTION "do_video_out()"
    AVCodecContext *enc;
    AVPacket pkt;

#ifdef DEBUG
    printf("%s %s: Entering with format context %p output stream %p buffer %p size %i\n", 
                DEBUGFILE, DEBUGFUNCTION, s, ost, buf, size);
#endif // DEBUG

    enc = ost->codec;

    // initialize video output packet
    av_init_packet(&pkt);
    pkt.size = size;
    if (enc->coded_frame)
//        pkt.pts = enc->coded_frame->pts;
        pkt.pts = av_rescale_q(enc->coded_frame->pts, 
                    enc->time_base, ost->time_base);
    if (enc->coded_frame && enc->coded_frame->key_frame)
        pkt.flags |= PKT_FLAG_KEY;
    pkt.stream_index = ost->index;
    pkt.data = buf;

    if (av_write_frame(s, &pkt) != 0) {
        fprintf(stderr, "%s %s: Error while writing video frame\n",
                    DEBUGFILE, DEBUGFUNCTION);
        exit(1);
    }

#ifdef DEBUG
    printf("%s %s: Leaving\n", DEBUGFILE, DEBUGFUNCTION);
#endif // DEBUG

    #undef DEBUGFUNCTION
}


#ifdef DEBUG
/*
// 
//dump info about XImage - for debugging purposes
//
void x2ffmpeg_dump_ximage_info(XImage * img, FILE * fp)
{
    #define DEBUGFUNCTION "x2ffmpeg_dump_ximage_info()"

#ifdef DEBUG
    printf("%s %s: Entering with image %p and file pointer %p\n", 
                DEBUGFILE, DEBUGFUNCTION, img, fp);
#endif // DEBUG

    fprintf(fp, " width %d\n", img->width);
    fprintf(fp, " height %d\n", img->height);
    fprintf(fp, " xoffset %d\n", img->xoffset);
    fprintf(fp, " format %d\n", img->format);
    fprintf(fp, " data addr 0x%X\n", (int) img->data);
    fprintf(fp, " first four bytes of data 0x%X 0x%X 0x%X 0x%X\n",
            (unsigned char) (img->data[0]), (unsigned char) (img->data[1]),
            (unsigned char) img->data[2], (unsigned char) img->data[3]);
    fprintf(fp, " byte_order %s\n",
            img->byte_order ? "MSBFirst" : "LSBFirst");
    fprintf(fp, " bitmap_unit %d\n", img->bitmap_unit);
    fprintf(fp, " bitmap_bit_order %s\n",
            img->bitmap_bit_order ? "MSBFirst" : "LSBFirst");
    fprintf(fp, " bitmap_pad %d\n", img->bitmap_pad);
    fprintf(fp, " depth %d\n", img->depth);
    fprintf(fp, " bytes_per_line %d\n", img->bytes_per_line);
    fprintf(fp, " bits_per_pixel %d\n", img->bits_per_pixel);
    fprintf(fp, " red_mask 0x%.8X\n", img->red_mask);
    fprintf(fp, " green_mask 0x%.8X\n", img->green_mask);
    fprintf(fp, " blue_mask 0x%.8X\n", img->blue_mask);

#ifdef DEBUG
    printf("%s %s: Leaving\n", DEBUGFILE, DEBUGFUNCTION);
#endif // DEBUG

    #undef DEBUGFUNCTION
}
*/

//
// dump 32bit image to pnm
//this is just used for debugging purposes
//
void dump32bit(XImage * input)
{
    #define DEBUGFUNCTION "dump32bit()"

    int row, col;
    static char head[256];

    static FILE *fp2 = NULL;
    uint8_t *ptr2, *output;
    long size;

    register unsigned int
        rm = input->red_mask,
        gm = input->green_mask,
        bm = input->blue_mask,
        rs = c_info.red_shift,
        gs = c_info.green_shift,
        bs = c_info.blue_shift, *p32 = (unsigned int *) input->data;

#ifdef DEBUG
    printf("%s %s: Entering with image %p\n", 
                DEBUGFILE, DEBUGFUNCTION, input);
#endif // DEBUG

    sprintf(head, "P6\n%d %d\n%d\n", input->width, input->height, 255);
    size = ((input->bytes_per_line * input->height) / 4) * 3;
    output = malloc(size);
    ptr2 = output;

    for (row = 0; row < input->height; row++) {
        for (col = 0; col < input->width; col++) {
            *output++ = ((*p32 & rm) >> rs);
            *output++ = ((*p32 & gm) >> gs);
            *output++ = ((*p32 & bm) >> bs);
            p32++; // ignore alpha values
        }
        // 
        // eat paded bytes, for better speed we use shifting,
        // (bytes_per_line - bits_per_pixel / 8 * width ) / 4 
        //
        p32 += (input->bytes_per_line - (input->bits_per_pixel >> 3)
                * input->width) >> 2;
    }

    fp2 = fopen("/tmp/pic.rgb.pnm", "w");
    fwrite(head, strlen(head), 1, fp2);
    // 
    // x2ffmpeg_dump_ximage_info (input, fp2); 
    //
    fwrite(ptr2, size, 1, fp2);
    fclose(fp2);
    free(ptr2);

#ifdef DEBUG
    printf("%s %s: Leaving\n", DEBUGFILE, DEBUGFUNCTION);
#endif // DEBUG

    #undef DEBUGFUNCTION
}

/*
// 
// dump 8 bit image to ppm
// this is just used for debugging purposes
//
void dump8bit(XImage * image, u_int32_t * ct)
{
    #define DEBUGFUNCTION "dump8bit()"

    static char head[256];
    static unsigned int image_size;
    register unsigned char *line_ptr, *col_ptr;
    unsigned char *pnm_image = NULL;
    int row, col;

    static FILE *fp2 = NULL;

#ifdef DEBUG
    printf("%s %s: Entering with image %p and file pointer %p\n", 
                DEBUGFILE, DEBUGFUNCTION, img, fp);
#endif // DEBUG

    sprintf(head, "P6\n%d %d\n%d\n", image->width, image->height, 255);
    image_size = image->width * 3 * image->height; // RGB
    pnm_image = (unsigned char *) malloc(image_size);

    fp2 = fopen("/tmp/pic.rgb.pnm", "w");
    fwrite(head, strlen(head), 1, fp2);

    line_ptr = pnm_image;
    for (row = 0; row < image->height; row++) {
        col_ptr = image->data + (row * image->bytes_per_line);
        for (col = 0; col < image->width; col++) {
            *line_ptr++ = ((ct[*col_ptr] & 0x00FF0000) >> 16);
            *line_ptr++ = ((ct[*col_ptr] & 0x0000FF00) >> 8);
            *line_ptr++ = (ct[*col_ptr] & 0x000000FF);
            col_ptr++;
        }
    }
    fwrite(pnm_image, image_size, 1, fp2);

    //
    // x2ffmpeg_dump_ximage_info (input, fp2); 
    //
    fclose(fp2);
    free(pnm_image);

#ifdef DEBUG
    printf("%s %s: Leaving\n", DEBUGFILE, DEBUGFUNCTION);
#endif // DEBUG

    #undef DEBUGFUNCTION
}
*/
#endif // DEBUG 




void prepareOutputFile(char *jFileName, AVFormatContext * oc, int mvNum)
{
    #define DEBUGFUNCTION "prepareOutputFile()"

#ifdef DEBUG
    printf("%s %s: Entering with filename %s format context %p and movie number %i\n", 
                DEBUGFILE, DEBUGFUNCTION, jFileName, oc, mvNum);
#endif // DEBUG

    // prepare output file for format context 

    if ((strcasecmp(jFileName, "-") == 0)
                || (strcasecmp(jFileName, "pipe:") == 0)) {
        jFileName = "pipe:";
        snprintf(oc->filename, sizeof(oc->filename), "pipe:");
        // register_protocol (&pipe_protocol);
    } else {
        char first;
        char tmp_buf[PATH_MAX + 1];

        first = jFileName[0];
        sprintf(tmp_buf, jFileName, mvNum);

        // if the filename's first char is a / we have an absolute path
        // and we want one for the file URL. If we don't have one, we
        // construct one 
        if (first != '/') {
            sprintf(oc->filename, "file://%s/%s", getenv("PWD"), tmp_buf);
        } else {
            sprintf(oc->filename, "file://%s", tmp_buf);
        }
        // register_protocol (&file_protocol);
    }
    
#ifdef DEBUG
    printf("%s %s: Leaving with filename %s\n", DEBUGFILE, DEBUGFUNCTION, oc->filename);
#endif // DEBUG

    #undef DEBUGFUNCTION
}



/* 
 * add a video output stream 
 */
AVStream *add_video_stream(AVFormatContext * oc, XImage * image, int input_pixfmt,
                           int codec_id, int fps, int quality)
{
    #define DEBUGFUNCTION "add_video_stream()"
    AVStream *st;
    int pix_fmt_mask = 0, i = 0;

#ifdef DEBUG
    printf("%s %s: Entering\n", DEBUGFILE, DEBUGFUNCTION);
#endif // DEBUG

    st = av_new_stream(oc, 0);
    if (!st) {
        fprintf(stderr,
                "%s %s: Could not alloc output stream\n", DEBUGFILE, DEBUGFUNCTION);
        exit(1);
    }

    st->codec->codec_id = codec_id;
    st->codec->codec_type = CODEC_TYPE_VIDEO;

    // find the video encoder 
    codec = avcodec_find_encoder(st->codec->codec_id);
    if (!codec) {
        fprintf(stderr, "%s %s: video codec not found\n", 
                    DEBUGFILE, DEBUGFUNCTION);
        exit(1);
    }

    // put sample parameters 
    st->codec->bit_rate = 400000;
    // resolution must be a multiple of two ... this is taken care of
    //elsewhere 
    st->codec->width = image->width;
    st->codec->height = image->height;
    // time base: this is the fundamental unit of time (in seconds) in
    // terms of which frame timestamps are represented. for fixed-fps
    // content, timebase should be 1/framerate and timestamp increments
    // should be identically 1. 
    st->codec->time_base.den = fps;
    st->codec->time_base.num = 1;
    // emit one intra frame every fifty frames at most
    st->codec->gop_size = 50;

    // FIXME: use avcodec_find_best_pix_fmt
    for ( i = 0; codec->pix_fmts[i] != -1; i++ ) 
        pix_fmt_mask |= codec->pix_fmts[i];
    
    st->codec->pix_fmt = avcodec_find_best_pix_fmt(pix_fmt_mask, input_pixfmt,
            (input_pixfmt == PIX_FMT_ARGB32 ? 1 : 0), NULL);
    if ( st->codec->pix_fmt < 0 ) st->codec->pix_fmt = PIX_FMT_YUV420P;
    
#ifdef DEBUG
    printf("%s %s: pix_fmt_mask %i, has alpha %i, input_pixfmt %i, output pixfmt %i\n", 
            DEBUGFILE, DEBUGFUNCTION, pix_fmt_mask, (input_pixfmt == PIX_FMT_ARGB32 ? 1 : 0),
            input_pixfmt, st->codec->pix_fmt);
#endif // DEBUG


// FIXME: should be smth. like this:    
/*if(   (video_global_header&1)
       || (video_global_header==0 && (oc->oformat->flags & AVFMT_GLOBALHEADER))){
        video_enc->flags |= CODEC_FLAG_GLOBAL_HEADER;
        avctx_opts->flags|= CODEC_FLAG_GLOBAL_HEADER;
    }
    if(video_global_header&2){
        video_enc->flags2 |= CODEC_FLAG2_LOCAL_HEADER;
        avctx_opts->flags2|= CODEC_FLAG2_LOCAL_HEADER;
    }
*/
    
    // some formats want stream headers to be seperate
    if (oc->oformat->name && ( !strcmp(oc->oformat->name, "mp4")
        || !strcmp(oc->oformat->name, "mov")
        || !strcmp(oc->oformat->name, "3gp")))
        st->codec->flags |= CODEC_FLAG_GLOBAL_HEADER;

#ifdef DEBUG
    printf("%s %s: here\n", DEBUGFILE, DEBUGFUNCTION);
#endif // DEBUG

    st->codec->bit_rate =
        (st->codec->width * st->codec->height *
         (((((st->codec->height + st->codec->width) / 100) - 5) >> 1) +
          10) * quality) / 100;
    if (st->codec->bit_rate < 300000)
        st->codec->bit_rate = 300000;

#ifdef DEBUG
    printf("%s %s: bitrate = %i\n", DEBUGFILE, DEBUGFUNCTION,
                st->codec->bit_rate);
#endif

    // st->codec->me_method = ME_EPZS;
    // st->codec->debug = 0x00000FFF;

#ifdef DEBUG
    printf("%s %s: Leaving\n", DEBUGFILE, DEBUGFUNCTION);
#endif // DEBUG

    return st;

    #undef DEBUGFUNCTION
}




/* 
 * write ximage as mpeg file to 'fp'
 */
void XImageToFFMPEG(FILE * fp, XImage * image, Job * job)
{
    #define DEBUGFUNCTION "XImageToFFMPEG()"

    AVFormatParameters fParams, *p_fParams = &fParams;  // video stream params
    AVFormatParameters params, *ap = &params;   // audio stream params
    AVImageFormat *image_format = NULL;
    int err;

#ifdef DEBUG
        printf("%s %s: Entering\n", DEBUGFILE, DEBUGFUNCTION);
#endif // DEBUG

    // encoder needs to be prepared only once .. 
    if (job->state & VC_START ) {   // it's the first call

#ifdef DEBUG
            printf("%s %s: doing x2ffmpeg init for targetCodec %i\n", 
                        DEBUGFILE, DEBUGFUNCTION, job->targetCodec);
#endif // DEBUG 

        // determine input picture format 
        //
        // FIXME: test for exotic formats
        // endianness is treated by avcodec

        // color info only needs to be retrieved once for true color X ... 
        // dunno about pseudo color 
        xvc_get_color_info(image, &c_info);

#ifdef DEBUG
        {
            FILE *errout;

            printf("%s %s: got color info\n", DEBUGFILE, DEBUGFUNCTION);
            errout = fdopen(2, "w");
//            x2ffmpeg_dump_ximage_info(image, errout);
            printf("%s %s: alpha_mask: 0x%.8X\n",
                    DEBUGFILE, DEBUGFUNCTION, c_info.alpha_mask);
            printf("%s %s: alpha_shift: %li\n",
                    DEBUGFILE, DEBUGFUNCTION, c_info.alpha_shift);
            printf("%s %s: red_shift: %li\n",
                    DEBUGFILE, DEBUGFUNCTION, c_info.red_shift);
            printf("%s %s: green_shift: %li\n",
                    DEBUGFILE, DEBUGFUNCTION, c_info.green_shift);
            printf("%s %s: blue_shift: %li\n",
                    DEBUGFILE, DEBUGFUNCTION, c_info.blue_shift);
        }
#endif // DEBUG 

#ifdef DEBUG
            printf("%s %s: image->byte_order: %i, msb=%i, lsb=%i\n",
                    DEBUGFILE, DEBUGFUNCTION, image->byte_order, MSBFirst, LSBFirst);
#endif // DEBUG

        switch (image->bits_per_pixel) {
        case 8:
#ifdef DEBUG
                printf("%s %s: 8 bit pallete\n", DEBUGFILE, DEBUGFUNCTION);
#endif // DEBUG 
            input_pixfmt = PIX_FMT_PAL8;
            break;
        case 16:
            if (image->red_mask == 0xF800 && image->green_mask == 0x07E0
                && image->blue_mask == 0x1F) {
#ifdef DEBUG
                    printf("%s %s: 16 bit RGB565\n", DEBUGFILE, DEBUGFUNCTION);
#endif // DEBUG 
                input_pixfmt = PIX_FMT_RGB565;
            } else if (image->red_mask == 0x7C00
                       && image->green_mask == 0x03E0
                       && image->blue_mask == 0x1F) {
#ifdef DEBUG
                    printf("%s %s: 16 bit RGB555\n", DEBUGFILE, DEBUGFUNCTION);
#endif // DEBUG 
                input_pixfmt = PIX_FMT_RGB555;

            } else {
                fprintf(stderr,
                        "%s %s: rgb ordering at image depth %i not supported ... aborting\n",
                        DEBUGFILE, DEBUGFUNCTION, image->bits_per_pixel);
                fprintf(stderr,
                        "%s %s: color masks: r 0x%.6lX g 0x%.6lX b 0x%.6lX\n",
                        DEBUGFILE, DEBUGFUNCTION, image->red_mask, image->green_mask,
                        image->blue_mask);
                exit(1);
            }
            break;
        case 24:
            if (image->red_mask == 0xFF0000 && image->green_mask == 0xFF00
                && image->blue_mask == 0xFF) {
                input_pixfmt = PIX_FMT_BGR24;
            } else if (image->red_mask == 0xFF
                       && image->green_mask == 0xFF00
                       && image->blue_mask == 0xFF0000) {
                input_pixfmt = PIX_FMT_RGB24;
            } else {
                fprintf(stderr,
                        "%s %s: rgb ordering at image depth %i not supported ... aborting\n",
                        DEBUGFILE, DEBUGFUNCTION,
                        image->bits_per_pixel);
                fprintf(stderr,
                        "%s %s: color masks: r 0x%.6lX g 0x%.6lX b 0x%.6lX\n",
                        DEBUGFILE, DEBUGFUNCTION,
                        image->red_mask, image->green_mask,
                        image->blue_mask);
                exit(1);
            }
            break;
        case 32:
            if (c_info.alpha_mask == 0xFF000000
                && image->green_mask == 0xFF00) {
                // byte order is relevant here, not endianness
                // endianness is handled by avcodec, but atm no such thing
                // as having ABGR, instead of ARGB in a word. Since we
                // need this for Solaris/SPARC, but need to do the
                // conversion
                // for every frame we do it outside of this loop, cf.
                // below
                // this matches both ARGB32 and ABGR32
                input_pixfmt = PIX_FMT_ARGB32;
            } else {
                fprintf(stderr,
                        "%s %s: image depth %i not supported ... aborting\n",
                        DEBUGFILE, DEBUGFUNCTION,
                        image->bits_per_pixel);
                exit(1);
            }
            break;
        default:
            fprintf(stderr,
                    "%s %s: image depth %i not supported ... aborting\n",
                    DEBUGFILE, DEBUGFUNCTION,
                    image->bits_per_pixel);
            exit(1);
        }

        // register all libav* related stuff
        av_register_all();

        // next call the right init() function for the file format (e.g.
        // avienc_init()) 
        if ( tFFormats[job->target].init ) (*tFFormats[job->target].init) ();  
        // guess AVOutputFormat
        if ( job->target >= CAP_MF )
            file_oformat =
                    guess_format(tFFormats[job->target].ffmpeg_name, NULL, NULL);
        else {
            char tmp_fn[30];
            snprintf(tmp_fn, 29, "test-%%d.%s", xvc_next_element(tFFormats[job->target].extensions));
            file_oformat = guess_format(NULL, tmp_fn, NULL);
        }
      
#ifdef DEBUG
        printf("%s %s: found AVOutputFormat %s it expects a number in the filename (0=no/1=yes) %i\n", 
                DEBUGFILE, DEBUGFUNCTION, file_oformat->name, (file_oformat->flags & AVFMT_NEEDNUMBER));
        printf("%s %s: found based on: target %i - targetCodec %i - ffmpeg codec id %i\n", 
                DEBUGFILE, DEBUGFUNCTION, job->target, job->targetCodec, tCodecs[job->targetCodec].ffmpeg_id);
#endif // DEBUG

        // prepare AVFormatContext
        output_file = av_alloc_format_context();
        if (!output_file) {
            fprintf(stderr,
                    "%s %s: Error allocating memory for format context ... aborting\n",
                    DEBUGFILE, DEBUGFUNCTION);
            exit(1);
        }
        output_file->oformat = file_oformat;
        output_file->priv_data = av_mallocz (output_file->oformat->priv_data_size); 
        // FIXME: do I need to free this?
        if (!output_file->priv_data && output_file->oformat->priv_data_size > 0) { 
            fprintf (stderr, 
                    "%s %s: Error allocating private data for format context ... aborting\n",
                    DEBUGFILE, DEBUGFUNCTION); 
            exit (1); 
        } 
        
        // prepare output filenames and register protocols
        // after this output_file->filename should have the right filename
        // FIXME: I may not need this for single-frame capture
        prepareOutputFile(job->file, output_file, job->movie_no);


        // add the video stream and initialize the codecs 
        //
        // prepare stream 
        out_st =
            add_video_stream(output_file, image, input_pixfmt, tCodecs[job->targetCodec].ffmpeg_id,
                             (job->fps / 100), job->quality);

        // FIXME: set params
        // memset (p_fParams, 0, sizeof(*p_fParams));
        // p_fParams->image_format = image_format;
        // p_fParams->time_base.den = out_st->codec->time_base.den;
        // p_fParams->time_base.num = out_st->codec->time_base.num;
        // p_fParams->width = out_st->codec->width;
        // p_fParams->height = out_st->codec->height; 
        // if (av_set_parameters (output_file, p_fParams) < 0) {
        if (av_set_parameters(output_file, NULL) < 0) {
            fprintf(stderr,
                    "%s %s: Invalid encoding parameters ... aborting\n",
                    DEBUGFILE, DEBUGFUNCTION);
            exit(1);
        }


        // open the codec 
//        c = out_st->codec;

        if (avcodec_open(out_st->codec, codec) < 0) {
            fprintf(stderr, "%s %s: could not open video codec\n",
                        DEBUGFILE, DEBUGFUNCTION);
            exit(1);
        }

        // open the file 
        if (url_fopen(&output_file->pb, output_file->filename, URL_WRONLY) < 0) {
            fprintf(stderr,
                    "%s %s: Could not open '%s' ... aborting\n", DEBUGFILE, DEBUGFUNCTION,
                    output_file->filename);
            exit(1);
        }

        if (av_write_header(output_file) < 0) {
            dump_format(output_file, 0, output_file->filename, 1);
            fprintf(stderr,
                    "%s %s: Could not write header for output file (incorrect codec paramters ?) ... aborting\n",
                    DEBUGFILE, DEBUGFUNCTION);
            exit(1);
        }

        /* 
         * prepare pictures 
         */
        p_inpic = &inpic;
        p_outpic = &outpic;

        image_size =
            avpicture_get_size(out_st->codec->pix_fmt, out_st->codec->width, out_st->codec->height);
        pic_out = av_malloc(image_size);
        if (!pic_out) {
            fprintf(stderr,
                    "%s %s: Could not allocate buffer for YUV pic (pic_out)! ... aborting\n",
                    DEBUGFILE, DEBUGFUNCTION);
            exit(1);
        }
        avpicture_fill(p_outpic, pic_out, out_st->codec->pix_fmt, out_st->codec->width,
                       out_st->codec->height);

        if (input_pixfmt == PIX_FMT_PAL8) {
            scratchbuf8bit = malloc(avpicture_get_size(input_pixfmt, out_st->codec->width, out_st->codec->height));

            avpicture_fill(p_inpic, scratchbuf8bit, input_pixfmt, out_st->codec->width,
                           out_st->codec->height);
            p_inpic->data[1] = job->color_table;
#ifdef DEBUG
                printf("%s %s: first 4 colors a r g b each: 0x%.8X 0x%.8X 0x%.8X 0x%.8X\n",
                        DEBUGFILE, DEBUGFUNCTION,
                        *(u_int32_t *) (job->color_table),
                        *((u_int32_t *) (job->color_table) + 1),
                        *((u_int32_t *) (job->color_table) + 2),
                        *((u_int32_t *) (job->color_table) + 3));
#endif // DEBUG 
        } else {
            avpicture_fill(p_inpic, image->data, input_pixfmt, out_st->codec->width,
                           out_st->codec->height);
        }

        frame = avcodec_alloc_frame();
        frame->type = FF_BUFFER_TYPE_SHARED;

        frame->data[0] = pic_out;
        frame->data[1] = frame->data[0] + (out_st->codec->width * out_st->codec->height);
        frame->data[2] = frame->data[1] + (out_st->codec->width * out_st->codec->height) / 4;
        frame->data[3] = NULL;
        frame->linesize[0] = out_st->codec->width;
        frame->linesize[1] = out_st->codec->width / 2;
        frame->linesize[2] = out_st->codec->width / 2;
        frame->linesize[3] = 0;


        /* 
         * prepare output buffer for encoded frames 
         */
        outbuf = malloc(image_size);
        if (!outbuf) {
            fprintf(stderr,
                    "%s %s: Could not allocate buffer for encoded frame (outbuf)! ... aborting\n",
                    DEBUGFILE, DEBUGFUNCTION);
            exit(1);
        }
#ifdef DEBUG
            printf("%s %s: leaving xffmpeg init\n", DEBUGFILE, DEBUGFUNCTION);
#endif // DEBUG 
    }

    /* 
     * convert input pic to pixel format the encoder expects 
     */
#ifdef DEBUG

    if (input_pixfmt == PIX_FMT_ARGB32)
        dump32bit(image);
/*    if (input_pixfmt == PIX_FMT_PAL8)
        dump8bit(image, (u_int32_t *) job->color_table);
*/
#endif // DEBUG 

    if ( img_convert(p_outpic, out_st->codec->pix_fmt,
                p_inpic, input_pixfmt, out_st->codec->width, out_st->codec->height) < 0) {
        fprintf(stderr,
                "%s %s: pixel format conversion not handled ... aborting\n",
                DEBUGFILE, DEBUGFUNCTION);
        exit(1);
    }
    
#ifdef DEBUG
    {
        FILE *lfp;

        lfp = fopen("/tmp/pic.yuv", "w");
        fwrite(pic_out, image_size, 1, lfp);
        fclose(lfp);
    }
#endif                          /* DEBUG */

    /* 
     * encode the image 
     */
/*     out_st->time_base.num = out_st->codec->time_base.num;
     out_st->time_base.den = out_st->codec->time_base.den;
     out_st->pts.val = (double)out_st->pts.val * out_st->time_base.num / out_st->time_base.den; */
    out_size = avcodec_encode_video(out_st->codec, outbuf, image_size, frame);
    if (out_size < 0) {
        fprintf(stderr,
                "%s %s: error encoding frame: c %p, outbuf %p, size %i, frame %p\n", 
                DEBUGFILE, DEBUGFUNCTION, out_st->codec, outbuf, image_size, p_outpic);
        exit(1);
    }

    /* 
     * write frame to file 
     */
if (out_size > 0 ) {
    if ( job->target >= CAP_MF ) 
        do_video_out(output_file, out_st, outbuf, out_size);
    else 
        fwrite(outbuf, image_size, 1, fp);
}

}

/* 
 * KHB: FFMPEG cleanup
 */
void FFMPEGClean(Job * job)
{
    int j;

#ifdef DEBUG
        printf("%s %s: Entering\n", DEBUGFILE, DEBUGFUNCTION);
#endif // DEBUG 


    if (out_st) {
        avcodec_close(out_st->codec);
        out_st = NULL;
    }

    if (output_file) {
        /* 
         * write trailer 
         */
        av_write_trailer(output_file);
        /* 
         * free stream(s) ... probably always only one 
         */
        for (j = 0; j < output_file->nb_streams; j++)
            av_free(output_file->streams[j]);

        /* 
         * close file 
         */
        url_fclose(&output_file->pb);
        /* 
         * free format context 
         */
        av_free(output_file);
        output_file = NULL;
    }

    if (pic_out) {
        av_free(pic_out);
        pic_out = NULL;
    }
    // free(outbuf); /* avcodec seems to do that job */
    outbuf = NULL;
    if (frame) {
        free(frame);
        frame = NULL;
    }
    // avcodec_close(c);
    // free(c); /* according to ffmpeg's apiexample.c */
    // don't seem to need to close anything if I'm freeing the stream
    // prior to this ...
//    out_st->codec = NULL;
    p_inpic = NULL;
    p_outpic = NULL;

    codec = NULL;

    av_free_static();
#ifdef DEBUG
        printf("%s %s: Leaving\n", DEBUGFILE, DEBUGFUNCTION);
#endif // DEBUG 

#undef DEBUGFUNCTION
}

u_int32_t *FFMPEGcolorTable(XColor * colors, int ncolors) {}


#endif                          // HAVE_LIBAVCODEC
